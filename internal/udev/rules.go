package udev

import (
	"fmt"
	"strings"
	"time"
)

// RulesFilePath is the standard location for USB audio device udev rules.
const RulesFilePath = "/etc/udev/rules.d/99-usb-soundcards.rules"

// DeviceInfo contains information needed to generate a udev rule.
type DeviceInfo struct {
	PortPath string // Physical USB port (e.g., "1-1.4")
	BusNum   int    // USB bus number
	DevNum   int    // USB device number
	Product  string // Product name (optional, for documentation)
	Serial   string // Serial number (optional, for documentation)
}

// GenerateRule creates a single udev rule for persistent device mapping.
//
// Format (CRITICAL - must be byte-for-byte identical to bash version):
//
//	SUBSYSTEM=="sound", KERNEL=="controlC[0-9]*", ATTRS{busnum}=="X", ATTRS{devnum}=="Y", SYMLINK+="snd/by-usb-port/PORT"
//
// This creates a persistent symlink at /dev/snd/by-usb-port/{portPath}
// that always points to the same physical USB port, regardless of
// enumeration order.
//
// Parameters:
//   - portPath: Physical USB port (e.g., "1-1.4")
//   - busNum: USB bus number (must be positive)
//   - devNum: USB device number (must be positive)
//
// Returns:
//   - Single-line udev rule (no trailing newline)
//
// Example:
//
//	GenerateRule("1-1.4", 1, 5)
//	â†’ `SUBSYSTEM=="sound", KERNEL=="controlC[0-9]*", ATTRS{busnum}=="1", ATTRS{devnum}=="5", SYMLINK+="snd/by-usb-port/1-1.4"`
//
// Reference: usb-audio-mapper.sh generate_udev_rule() function
func GenerateRule(portPath string, busNum, devNum int) string {
	return fmt.Sprintf(
		`SUBSYSTEM=="sound", KERNEL=="controlC[0-9]*", ATTRS{busnum}=="%d", ATTRS{devnum}=="%d", SYMLINK+="snd/by-usb-port/%s"`,
		busNum,
		devNum,
		portPath,
	)
}

// GenerateRuleWithValidation creates a udev rule with input validation.
//
// This variant returns an error for invalid inputs, useful for
// CLI tools that need to provide user feedback.
//
// Parameters:
//   - portPath: Physical USB port (validated against pattern)
//   - busNum: USB bus number (must be positive)
//   - devNum: USB device number (must be positive)
//
// Returns:
//   - rule: Generated udev rule
//   - error: if any input is invalid
func GenerateRuleWithValidation(portPath string, busNum, devNum int) (string, error) {
	// Validate port path
	if portPath == "" {
		return "", fmt.Errorf("port path cannot be empty")
	}
	if !IsValidUSBPortPath(portPath) {
		return "", fmt.Errorf("invalid USB port path: %s", portPath)
	}

	// Validate bus/dev numbers (must be positive)
	if busNum <= 0 {
		return "", fmt.Errorf("invalid bus number: %d (must be positive)", busNum)
	}
	if devNum <= 0 {
		return "", fmt.Errorf("invalid dev number: %d (must be positive)", devNum)
	}

	return GenerateRule(portPath, busNum, devNum), nil
}

// GenerateRule is a convenience method on DeviceInfo.
func (d *DeviceInfo) GenerateRule() string {
	return GenerateRule(d.PortPath, d.BusNum, d.DevNum)
}

// GenerateRulesFile creates a complete udev rules file for multiple devices.
//
// The file format:
// - Header comment explaining purpose and generation timestamp
// - One rule per device
// - Final newline (required by udev)
//
// Parameters:
//   - devices: Slice of device info structs (can use anonymous structs)
//
// Returns:
//   - Complete file content ready to write to /etc/udev/rules.d/
//
// Example:
//
//	devices := []struct{ portPath string; busNum, devNum int }{
//	    {"1-1.4", 1, 5},
//	    {"1-1.5", 1, 6},
//	}
//	content := GenerateRulesFile(devices)
//	// Write to /etc/udev/rules.d/99-usb-soundcards.rules
func GenerateRulesFile(devices []struct {
	portPath string
	busNum   int
	devNum   int
}) string {
	var sb strings.Builder

	// Header comment
	sb.WriteString("# USB Audio Device udev rules\n")
	sb.WriteString("# Generated by lyrebird-usb\n")
	sb.WriteString(fmt.Sprintf("# Timestamp: %s\n", time.Now().UTC().Format(time.RFC3339)))
	sb.WriteString("#\n")
	sb.WriteString("# These rules create persistent symlinks at /dev/snd/by-usb-port/{port-path}\n")
	sb.WriteString("# based on physical USB port location, NOT enumeration order.\n")
	sb.WriteString("#\n")
	sb.WriteString("# After modifying this file, reload with:\n")
	sb.WriteString("#   sudo udevadm control --reload-rules && sudo udevadm trigger\n")
	sb.WriteString("\n")

	// Generate rule for each device
	for _, dev := range devices {
		rule := GenerateRule(dev.portPath, dev.busNum, dev.devNum)
		sb.WriteString(rule)
		sb.WriteString("\n")
	}

	return sb.String()
}

// WriteRulesFile writes the udev rules file to disk with proper permissions.
//
// This function performs the following operations:
// 1. Validates all device info
// 2. Generates rules file content
// 3. Writes to /etc/udev/rules.d/99-usb-soundcards.rules
// 4. Sets permissions to 0644 (root:root, readable by all)
// 5. Optionally reloads udev rules
//
// Parameters:
//   - devices: Slice of DeviceInfo structs
//   - reload: If true, automatically reload udev rules after writing
//
// Returns:
//   - error: if validation, writing, or reloading fails
//
// Example:
//
//	devices := []*DeviceInfo{
//	    {PortPath: "1-1.4", BusNum: 1, DevNum: 5},
//	    {PortPath: "1-1.5", BusNum: 1, DevNum: 6},
//	}
//	err := WriteRulesFile(devices, true)
//
// Reference: usb-audio-mapper.sh write_udev_rules() function
func WriteRulesFile(devices []*DeviceInfo, reload bool) error {
	// Validate all devices first
	for i, dev := range devices {
		if _, err := GenerateRuleWithValidation(dev.PortPath, dev.BusNum, dev.DevNum); err != nil {
			return fmt.Errorf("invalid device %d: %w", i, err)
		}
	}

	// Convert to anonymous struct slice for GenerateRulesFile
	anonDevices := make([]struct {
		portPath string
		busNum   int
		devNum   int
	}, len(devices))

	for i, dev := range devices {
		anonDevices[i] = struct {
			portPath string
			busNum   int
			devNum   int
		}{
			portPath: dev.PortPath,
			busNum:   dev.BusNum,
			devNum:   dev.DevNum,
		}
	}

	content := GenerateRulesFile(anonDevices)

	// Note: Actual file writing and permission setting will be implemented
	// in a separate function that requires elevated privileges.
	// This function is primarily for testing and validation.
	_ = content
	_ = reload

	return fmt.Errorf("WriteRulesFile not yet implemented - requires elevated privileges")
}
