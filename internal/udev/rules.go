// SPDX-License-Identifier: MIT

package udev

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"
)

// RulesFilePath is the standard location for USB audio device udev rules.
const RulesFilePath = "/etc/udev/rules.d/99-usb-soundcards.rules"

// DeviceInfo contains information needed to generate a udev rule.
type DeviceInfo struct {
	PortPath string // Physical USB port (e.g., "1-1.4")
	BusNum   int    // USB bus number
	DevNum   int    // USB device number
	Product  string // Product name (optional, for documentation)
	Serial   string // Serial number (optional, for documentation)
}

// GenerateRule creates a single udev rule for persistent device mapping.
//
// Format (CRITICAL - must be byte-for-byte identical to bash version):
//
//	SUBSYSTEM=="sound", KERNEL=="controlC[0-9]*", ATTRS{busnum}=="X", ATTRS{devnum}=="Y", SYMLINK+="snd/by-usb-port/PORT"
//
// This creates a persistent symlink at /dev/snd/by-usb-port/{portPath}
// that always points to the same physical USB port, regardless of
// enumeration order.
//
// Parameters:
//   - portPath: Physical USB port (e.g., "1-1.4")
//   - busNum: USB bus number (must be positive)
//   - devNum: USB device number (must be positive)
//
// Returns:
//   - Single-line udev rule (no trailing newline)
//
// Example:
//
//	GenerateRule("1-1.4", 1, 5)
//	â†’ `SUBSYSTEM=="sound", KERNEL=="controlC[0-9]*", ATTRS{busnum}=="1", ATTRS{devnum}=="5", SYMLINK+="snd/by-usb-port/1-1.4"`
//
// Reference: usb-audio-mapper.sh generate_udev_rule() function
func GenerateRule(portPath string, busNum, devNum int) string {
	return fmt.Sprintf(
		`SUBSYSTEM=="sound", KERNEL=="controlC[0-9]*", ATTRS{busnum}=="%d", ATTRS{devnum}=="%d", SYMLINK+="snd/by-usb-port/%s"`,
		busNum,
		devNum,
		portPath,
	)
}

// GenerateRuleWithValidation creates a udev rule with input validation.
//
// This variant returns an error for invalid inputs, useful for
// CLI tools that need to provide user feedback.
//
// Parameters:
//   - portPath: Physical USB port (validated against pattern)
//   - busNum: USB bus number (must be positive)
//   - devNum: USB device number (must be positive)
//
// Returns:
//   - rule: Generated udev rule
//   - error: if any input is invalid
func GenerateRuleWithValidation(portPath string, busNum, devNum int) (string, error) {
	// Validate port path
	if portPath == "" {
		return "", fmt.Errorf("port path cannot be empty")
	}
	if !IsValidUSBPortPath(portPath) {
		return "", fmt.Errorf("invalid USB port path: %s", portPath)
	}

	// Validate bus/dev numbers (must be positive)
	if busNum <= 0 {
		return "", fmt.Errorf("invalid bus number: %d (must be positive)", busNum)
	}
	if devNum <= 0 {
		return "", fmt.Errorf("invalid dev number: %d (must be positive)", devNum)
	}

	return GenerateRule(portPath, busNum, devNum), nil
}

// GenerateRule is a convenience method on DeviceInfo.
func (d *DeviceInfo) GenerateRule() string {
	return GenerateRule(d.PortPath, d.BusNum, d.DevNum)
}

// GenerateRulesFile creates a complete udev rules file for multiple devices.
//
// The file format:
// - Header comment explaining purpose and generation timestamp
// - One rule per device
// - Final newline (required by udev)
//
// Parameters:
//   - devices: Slice of DeviceInfo pointers
//
// Returns:
//   - Complete file content ready to write to /etc/udev/rules.d/
//
// Example:
//
//	devices := []*DeviceInfo{
//	    {PortPath: "1-1.4", BusNum: 1, DevNum: 5},
//	    {PortPath: "1-1.5", BusNum: 1, DevNum: 6},
//	}
//	content := GenerateRulesFile(devices)
//	// Write to /etc/udev/rules.d/99-usb-soundcards.rules
func GenerateRulesFile(devices []*DeviceInfo) string {
	var sb strings.Builder

	// Header comment
	sb.WriteString("# USB Audio Device udev rules\n")
	sb.WriteString("# Generated by lyrebird-usb\n")
	sb.WriteString(fmt.Sprintf("# Timestamp: %s\n", time.Now().UTC().Format(time.RFC3339)))
	sb.WriteString("#\n")
	sb.WriteString("# These rules create persistent symlinks at /dev/snd/by-usb-port/{port-path}\n")
	sb.WriteString("# based on physical USB port location, NOT enumeration order.\n")
	sb.WriteString("#\n")
	sb.WriteString("# After modifying this file, reload with:\n")
	sb.WriteString("#   sudo udevadm control --reload-rules && sudo udevadm trigger\n")
	sb.WriteString("\n")

	// Generate rule for each device
	for _, dev := range devices {
		rule := GenerateRule(dev.PortPath, dev.BusNum, dev.DevNum)
		sb.WriteString(rule)
		sb.WriteString("\n")
	}

	return sb.String()
}

// WriteRulesFile writes the udev rules file to disk with proper permissions.
//
// This function performs the following operations:
// 1. Validates all device info
// 2. Generates rules file content
// 3. Writes to the specified path (or default RulesFilePath)
// 4. Sets permissions to 0644 (readable by all)
// 5. Optionally reloads udev rules
//
// Parameters:
//   - devices: Slice of DeviceInfo structs
//   - reload: If true, automatically reload udev rules after writing
//
// Returns:
//   - error: if validation, writing, or reloading fails
//
// Example:
//
//	devices := []*DeviceInfo{
//	    {PortPath: "1-1.4", BusNum: 1, DevNum: 5},
//	    {PortPath: "1-1.5", BusNum: 1, DevNum: 6},
//	}
//	err := WriteRulesFile(devices, true)
//
// Reference: usb-audio-mapper.sh write_udev_rules() function
func WriteRulesFile(devices []*DeviceInfo, reload bool) error {
	return WriteRulesFileToPath(devices, RulesFilePath, reload)
}

// WriteRulesFileToPath writes the udev rules file to a specified path.
//
// This is the core implementation that allows specifying a custom path,
// useful for testing without requiring root access.
//
// Parameters:
//   - devices: Slice of DeviceInfo structs
//   - path: Destination file path
//   - reload: If true, automatically reload udev rules after writing
//
// Returns:
//   - error: if validation, writing, or reloading fails
func WriteRulesFileToPath(devices []*DeviceInfo, path string, reload bool) error {
	return writeRulesFileToPathWithRunner(devices, path, reload, defaultCmdRunner)
}

// writeRulesFileToPathWithRunner is the injectable implementation for testing.
func writeRulesFileToPathWithRunner(devices []*DeviceInfo, path string, reload bool, runner cmdRunner) error {
	// Validate all devices first
	for i, dev := range devices {
		if _, err := GenerateRuleWithValidation(dev.PortPath, dev.BusNum, dev.DevNum); err != nil {
			return fmt.Errorf("invalid device %d: %w", i, err)
		}
	}

	content := GenerateRulesFile(devices)

	// Write to file with 0644 permissions (readable by all, writable by owner)
	// #nosec G306 - udev rules must be world-readable (0644 is appropriate)
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write rules file: %w", err)
	}

	// Optionally reload udev rules
	if reload {
		if err := reloadUdevRulesWith(runner); err != nil {
			return fmt.Errorf("failed to reload udev rules: %w", err)
		}
	}

	return nil
}

// ReloadUdevRules reloads udev rules and triggers re-enumeration.
//
// This runs:
//   - udevadm control --reload-rules
//   - udevadm trigger
//
// Returns:
//   - error: if either command fails
func ReloadUdevRules() error {
	return reloadUdevRulesWith(defaultCmdRunner)
}

// cmdRunner is a function type for running OS commands, injectable for tests.
type cmdRunner func(name string, args ...string) ([]byte, error)

// defaultCmdRunner executes commands using os/exec.
func defaultCmdRunner(name string, args ...string) ([]byte, error) {
	cmd := exec.Command(name, args...) // #nosec G204
	return cmd.CombinedOutput()
}

// reloadUdevRulesWith reloads udev rules using the provided command runner.
func reloadUdevRulesWith(run cmdRunner) error {
	// Reload rules
	if output, err := run("udevadm", "control", "--reload-rules"); err != nil {
		return fmt.Errorf("udevadm control --reload-rules failed: %w: %s", err, string(output))
	}

	// Trigger re-enumeration
	if output, err := run("udevadm", "trigger"); err != nil {
		return fmt.Errorf("udevadm trigger failed: %w: %s", err, string(output))
	}

	return nil
}
